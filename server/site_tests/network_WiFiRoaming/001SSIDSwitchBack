# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This test run is designed to test that the connection manager is able
# to rejoin a previously connected AP when it loses connectivity to its
# current AP.  To accomplish this, we join one AP (so we are sure that
# this flimflam instance remembers it), then join a second AP which we
# yank while the DUT is connected to it.  We sit around and observe
# if and how long it takes for the connection manager to re-acquire
# connectivity to the first AP.
#
# Note that we yank the second AP (rather than shutting it down cleanly)
# to avoid a race condition. With a clean shut down, the connection manager
# may trigger a scan before the second AP is actually down. That causes
# the connection manager to attempt to reconnect to the second AP, rather
# than the first. (See crosbug.com/27148.)
#
{ "name":"SwitchBack",
  "steps":[
    [ "create",         { "type":"hostap" } ],

    [ "config",         { "channel":"2412", "mode":"11b",
                          "ssid_suffix": "t1"} ],

    # Connect to the first AP.  This just guarantees that this AP has
    # been placed in the connection manager profile.
    [ "connect",        { "security":"none" } ],
    [ "client_ping",    { "count":"10" } ],
    [ "deconfig" ],

    # Configure and connect to the second AP.
    # NB: use a 5GHz channel so it has a different BSSID (hack)
    [ "config",         { "channel":"5240", "mode":"11a",
                          "ssid_suffix": "t2"} ],
    [ "connect",        { "security":"none" } ],
    [ "client_ping",    { "count":"10" } ],
    [ "deconfig",             { "silent":None } ],  # Exit AP without DEAUTH

    # Shut down the second AP and bring the first on back up
    [ "config",         { "channel":"2462", "mode":"11b",
                          "ssid_suffix": "t1"} ],

    # Instead of explicitly connecting, just wait to see if the DUT
    # re-connects by itself
    [ "wait_service",   { "run_timeout":20,       # Timeout connection in 20 seconds
                          "debug":True,       # Print out all state transitions
                          "states":[
                             (None, 'ready')  # Wait for the "current AP" (as
                          ] } ],              # read of the AP -- "t1" above)
                                              # service to transition to "ready"
    [ "client_ping",    { "count":"10" } ],

    [ "destroy" ],
  ],
}

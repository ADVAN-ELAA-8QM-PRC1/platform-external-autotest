# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import logging
from autotest_lib.client.common_lib import error, utils
from autotest_lib.server import host_attributes

AUTHOR = "Chromium OS"
NAME = "autoupdate_EndToEndTest"
TIME = "MEDIUM"
TEST_CATEGORY = "Functional"
TEST_CLASS = "platform"
TEST_TYPE = "server"

DOC = """
This is an end-to-end update test of Chrome OS releases. Given a test
configuration, it will perform an end-to-end test of a Chrome OS update
payload. A test configuration can be given as command-line arguments (see
below) or instantiated inline as local varibles.

To invoke this test locally with an attached servo board:

  run_remote_tests.sh \
          --args="<ARGLIST>" \
          --remote=<DUT-IPADDR \
          --ssh_connect_timeout 2 \       # Make the test run faster
          --ssh_connection_attempts 2 \   # when not using test
          autoupdate_EndToEndTest

where ARGLIST is a whitespace separated list of the following key=value pairs.
Values pertaining to the test case include:

  name=TAG           name tag for the test (e.g. 'nmo', 'npo' or 'fsi')
  image_type=test|mp      type of images used, either 'test' or 'mp'
  update_type=full|delta  type of update being applied, either 'full' or 'delta'
  source_release=REL      source image release version (e.g. 2672.0.0)
  target_release=REL      target image release version (e.g. 2673.0.0)
  source_image_uri=URI    URI of the source image / payload. Image must be used
                          if use_servo specified.
  target_payload_uri=URI  URI of the target payload

Other values pertaining to the test environment include:

  servo_host=HOST         host running servod (if not set, servo won't be used)
  servo_port=PORT         servod's IP port (default: servod's default port)

Please note, this test spawns omaha server instances (devserver) on a devserver
configured in your global_config using autotest's ssh mechanism. This means that
if you are running this locally and intend to use a local devserver, you will
need to setup your ssh keys for public key authentication e.g. create keys,
ssh-add the private key, add the public key to your authorized keys and finally
enable public key authentication in your sshd config.
"""

TEST_CONF_KEYS = (
    'name', 'image_type', 'update_type', 'source_release', 'target_release',
    'source_image_uri', 'target_payload_uri')


args_dict = utils.args_to_dict(args)
use_servo = args_dict.get('servo_host', False)
servo_args = None
if use_servo:
    servo_args = hosts.SiteHost.get_servo_arguments(args_dict)

# Create test configuration based on command-line arguments (higher precedence,
# for run_remote_tests.sh invocation) and local variables (lower precedence,
# for Autotest front-end invocation).
test_conf = {}
for key in TEST_CONF_KEYS:
    test_conf[key] = args_dict.get(key) or locals().get(key)
    # Currently all args are required. #TODO(sosa) - make some optional.
    if not test_conf[key]:
        error.AutotestError('Must specify %s in arglist.' % key)


def run_test(machine):
    """Execute a test configuration on a given machine."""
    host = hosts.create_host(machine, servo_args=servo_args)
    try:
        unique_name_suffix = '%s_%s' % (test_conf['name'],
                             test_conf['source_release'].replace('.', '_'))
        job.run_test(
                "autoupdate_EndToEndTest_" + unique_name_suffix,
                tag='%s_%s' % (test_conf['image_type'],
                               test_conf['update_type']),
                host=host, test_conf=test_conf, use_servo=use_servo)
    except Exception as e:
        if not issubclass(type(e), error.TestBaseException):
            error_msg = 'Received test error: %s' % e
            logging.error(error_msg)
            raise error.TestError(error_msg)

        raise


# Invoke parallel tests.
parallel_simple(run_test, machines)

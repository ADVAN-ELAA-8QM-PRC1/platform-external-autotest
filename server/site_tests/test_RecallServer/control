# Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

AUTHOR = "Chromium OS Project"
NAME = "test_RecallServer"
PURPOSE = "Run a client test using a Recall server"
CRITERIA = """
This test will succeed if the client test specified succeeds.
"""
TIME = "SHORT"
TEST_CATEGORY = "General"
TEST_CLASS = "test"
TEST_TYPE = "server"

DOC = """
This test creates a Recall server instance, and runs a specified client
test on the client machine intercepting DNS, HTTP and HTTPS traffic for
recording, manipulation and later playback.

Sample usage:

  # Run desktopui_UrlFetch on the client, record results which can
  # be found as <RESULTS DIR>/pickle
  ./run_remote_tests.sh --remote=<DEVICE IP> test_RecallServer \
    -a 'desktopui_UrlFetch'

  # Run desktopui_UrlFetch on the client, only returning results
  # found in the given pickle file created from a previous recording
  ./run_remote_tests.sh --remote=<DEVICE IP> test_RecallServer \
    -a 'desktopui_UrlFetch /path/to/pickle'

  # Run desktopui_UrlFetch on the client 100 times, the first time
  # will be recorded, the subsequent 99 will use the playback only
  ./run_remote_tests.sh --remote=<DEVICE IP> test_RecallServer \
    -a 'desktopui_UrlFetch num_iterations=100'

  # Run desktopui_UrlFetch on the client using a simple proxy server
  # that doesn't record (mostly for infrastructure testing)
  ./run_remote_tests.sh --remote=<DEVICE IP> test_RecallServer \
    -a 'desktopui_UrlFetch proxy_only=1'

Infrastructure restrictions mean that this test must always be run as
root (or with sudo), and may not be run against the 127.0.0.1 address.
"""

dict_args = {}
if args:
    if args and '=' not in args[0]:
        dict_args['test'] = args.pop(0)
    if args and '=' not in args[0]:
        dict_args['pickle_file'] = args.pop(0)
    dict_args.update(x.split('=') for x in args)

def run(machine):
    host = hosts.create_host(machine)
    job.run_test("test_RecallServer", host=host, **dict_args)

parallel_simple(run, machines)

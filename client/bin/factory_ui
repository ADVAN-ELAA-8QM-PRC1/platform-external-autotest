#!/usr/bin/python
#
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


# DESCRIPTION :
#
# This UI is intended to be used by the factory autotest suite to
# provide factory operators feedback on test status and control over
# execution order.
#
# In short, the UI is composed of a 'console' panel on the bottom of
# the screen which displays the autotest log, and there is also a
# 'test list' panel on the right hand side of the screen.  The
# majority of the screen is dedicated to tests, which are executed in
# seperate processes, but instructed to display their own UIs in this
# dedicated area whenever possible.  Tests in the test list are
# executed in order by default, but can be activated on demand via
# associated keyboard shortcuts.  As tests are run, their status is
# color-indicated to the operator -- greyed out means untested, yellow
# means active, green passed and red failed.


import gobject
import gtk
import imp
import os
import pango
import subprocess
import sys
import time

import common
import factory
import factory_ui_lib as ful


# These definitions are expose these classes directly into this
# namespace, so that the test_list that is sent from the control file
# can have cleaner syntax.  These are done in this fashion, as opposed
# to "from factory import <class>" to work-around Python namespace
# wackiness -- the from syntax does not work, creating new classes.
OperatorTest = factory.OperatorTest
InformationScreen = factory.InformationScreen
AutomatedSequence = factory.AutomatedSequence
AutomatedSubTest = factory.AutomatedSubTest
AutomatedRebootSubTest = factory.AutomatedRebootSubTest


_SEP_COLOR = gtk.gdk.color_parse('grey50')

_LABEL_EN_SIZE = (170, 35)
_LABEL_ZW_SIZE = (70, 35)
_LABEL_EN_FONT = pango.FontDescription('courier new extra-condensed 16')
_LABEL_ZW_FONT = pango.FontDescription('normal 12')
_LABEL_T_SIZE = (30, 35)
_LABEL_T_FONT = pango.FontDescription('courier new italic ultra-condensed 10')
_LABEL_UNTESTED_FG = gtk.gdk.color_parse('grey40')
_LABEL_TROUGH_COLOR = gtk.gdk.color_parse('grey20')
_LABEL_STATUS_SIZE = (140, 30)
_LABEL_STATUS_FONT = pango.FontDescription(
    'courier new bold extra-condensed 16')
_OTHER_LABEL_FONT = pango.FontDescription('courier new condensed 20')

_ST_LABEL_EN_SIZE = (250, 35)
_ST_LABEL_ZW_SIZE = (150, 35)

_STATUS_REFRESH_MS = 100

class Console:
    '''Display a progress log.  Implemented by launching an borderless
    xterm at a strategic location, and running tail against the log.'''

    def __init__(self, allocation):
        xterm_coords = '135x14+%d+%d' % (allocation.x, allocation.y)
        factory.log('xterm_coords = %s' % xterm_coords)
        xterm_cmd = (('aterm --geometry %s -bw 0 -e bash -c ' %
                      xterm_coords).split() +
                     ['tail -f %s | grep FACTORY' % factory.LOG_PATH])
        factory.log('xterm_cmd = %s' % xterm_cmd)
        self._proc = subprocess.Popen(xterm_cmd)

    def __del__(self):
        factory.log('console_proc __del__')
        self._proc.kill()


# Capture keyboard events here for debugging -- under normal
# circumstances, all keyboard events should be captured by executing
# tests, and hence this should not be called.

def handle_key_release_event(_, event):
    factory.log('base ui key event (%s)' % event.keyval)
    return True


class TestLabelBox(gtk.EventBox):

    def __init__(self, test):
        gtk.EventBox.__init__(self)
        self.modify_bg(gtk.STATE_NORMAL, ful.LABEL_COLORS[ful.UNTESTED])

        label_en = ful.make_label(test.label_en, size=_LABEL_EN_SIZE,
                                  font=_LABEL_EN_FONT, alignment=(0.5, 0.5),
                                  fg=_LABEL_UNTESTED_FG)
        label_zw = ful.make_label(test.label_zw, size=_LABEL_ZW_SIZE,
                                  font=_LABEL_ZW_FONT, alignment=(0.5, 0.5),
                                  fg=_LABEL_UNTESTED_FG)
        label_t = ful.make_label('C-' + test.kbd_shortcut, size=_LABEL_T_SIZE,
                                 font=_LABEL_T_FONT, alignment=(0.5, 0.5),
                                 fg=ful.BLACK)
        hbox = gtk.HBox()
        hbox.pack_start(label_en, False, False)
        hbox.pack_start(label_zw, False, False)
        hbox.pack_start(label_t, False, False)
        self.add(hbox)
        self.label_list = [label_en, label_zw]

    def update(self, status):
        label_fg = status == ful.UNTESTED and _LABEL_UNTESTED_FG or ful.BLACK
        for label in self.label_list:
            label.modify_fg(gtk.STATE_NORMAL, label_fg)
        self.modify_bg(gtk.STATE_NORMAL, ful.LABEL_COLORS[status])
        self.queue_draw()


class SubTestLabelBox(gtk.EventBox):

    def __init__(self, test):
        gtk.EventBox.__init__(self)
        self.modify_bg(gtk.STATE_NORMAL, ful.BLACK)
        label_status = ful.make_label(ful.UNTESTED, size=_LABEL_STATUS_SIZE,
                                      alignment=(0, 0.5),
                                      font=_LABEL_STATUS_FONT,
                                      fg=_LABEL_UNTESTED_FG)
        label_sep = ful.make_label(' : ', alignment=(0.5, 0.5),
                                   font=_LABEL_EN_FONT)
        label_en = ful.make_label(test.label_en, size=_ST_LABEL_EN_SIZE,
                                  alignment=(0.5, 0.5),
                                  font=_LABEL_EN_FONT)
        label_zw = ful.make_label(test.label_zw, size=_ST_LABEL_ZW_SIZE,
                                  alignment=(0.5, 0.5), font=_LABEL_ZW_FONT)
        hbox = gtk.HBox()
        hbox.pack_end(label_status, False, False)
        hbox.pack_end(label_sep, False, False)
        hbox.pack_end(label_zw, False, False)
        hbox.pack_end(label_en, False, False)
        self.add(hbox)
        self.label_status = label_status

    def update(self, status):
        if status == ful.UNTESTED:
            return
        self.label_status.set_text(status)
        self.label_status.modify_fg(gtk.STATE_NORMAL, ful.LABEL_COLORS[status])
        self.queue_draw()


class UiState():

    def __init__(self, window, status_map, test_widget_box):

        def make_empty_test_label_widget():
            label_box = gtk.EventBox()
            label_box.modify_bg(gtk.STATE_NORMAL, ful.BLACK)
            label = ful.make_label('no active test', font=_OTHER_LABEL_FONT,
                                   alignment=(0.5, 0.5))
            label_box.add(label)
            return label_box

        def make_automated_seq_label_widget(subtest_list):
            vbox = gtk.VBox()
            vbox.set_spacing(0)
            for subtest in subtest_list:
                label_box = SubTestLabelBox(subtest)
                status_map.set_label_box(subtest, label_box)
                vbox.pack_start(status_map.lookup_label_box(subtest),
                                False, False)
            return vbox

        self._window = window
        self._status_map = status_map
        self._test_widget_box = test_widget_box
        self._empty_test_widget = make_empty_test_label_widget()
        self._active_test_widget = self._empty_test_widget
        self.active_test = None

        self._test_widget_box.add(self._empty_test_widget)

        self._automated_seq_widget_map = dict(
            (t, make_automated_seq_label_widget(t.subtest_list))
            for t in self._status_map.test_db.seq_test_set)

    def set_active_test(self, test):
        '''Control what kind of widget is shown in the testing area of
        the screen.  For normal operator tests, this is just a label
        saying there is no active test.  The expectation is that the
        operator test itself has a window obscuring this message.  For
        automated sequences, since there is no other window, the no
        active test message is replaced with an updated list of
        subtest status.'''
        if test == self.active_test:
            return
        self.active_test = test
        self._test_widget_box.remove(self._active_test_widget)
        active_widget = (test in self._status_map.test_db.seq_test_set
                         and self._automated_seq_widget_map[test]
                         or self._empty_test_widget)
        self._test_widget_box.add(active_widget)
        self._active_test_widget = active_widget
        self._window.show_all()


def make_hsep(width=1):
    frame = gtk.EventBox()
    frame.set_size_request(-1, width)
    frame.modify_bg(gtk.STATE_NORMAL, _SEP_COLOR)
    return frame


def make_vsep(width=1):
    frame = gtk.EventBox()
    frame.set_size_request(width, -1)
    frame.modify_bg(gtk.STATE_NORMAL, _SEP_COLOR)
    return frame


def refresh_status(status_map, ui_state):
    status_map.read_new_data()
    active_test = status_map.get_active_top_level_test()
    ui_state.set_active_test(active_test)
    return True


def main():
    '''This process is launched by the autotest suite_Factory control
    process.  Communication with this process is an exchange of well
    formed python expressions over stdin and stdout.  Basically
    sending wraps arguments in a call to repr() and recv calls eval()
    to re-generate the python data.'''

    def control_recv():
      return eval(sys.stdin.readline().rstrip())

    def control_send(x):
      print repr(x)
      sys.stdout.flush()

    # On startup, get the list of tests to run (in order) and the
    # autotest status file path.
    factory.log('pulling control info')
    test_list = control_recv()
    status_file_path = control_recv()

    status_map = factory.StatusMap(test_list, status_file_path)

    window = gtk.Window(gtk.WINDOW_TOPLEVEL)
    window.connect('destroy', lambda _: gtk.main_quit())
    window.modify_bg(gtk.STATE_NORMAL, ful.BLACK)

    screen = window.get_screen()
    screen_size = (screen.get_width(), screen.get_height())
    window.set_size_request(*screen_size)

    label_trough = gtk.VBox()
    label_trough.set_spacing(0)

    rhs_box = gtk.EventBox()
    rhs_box.modify_bg(gtk.STATE_NORMAL, _LABEL_TROUGH_COLOR)
    rhs_box.add(label_trough)

    console_box = gtk.EventBox()
    console_box.set_size_request(-1, 180)
    console_box.modify_bg(gtk.STATE_NORMAL, ful.BLACK)

    test_widget_box = gtk.Alignment(xalign=0.5, yalign=0.5)
    test_widget_box.set_size_request(-1, -1)

    ui_state = UiState(window, status_map, test_widget_box)

    lhs_box = gtk.VBox()
    lhs_box.pack_end(console_box, False, False)
    lhs_box.pack_start(test_widget_box)
    lhs_box.pack_start(make_hsep(3), False, False)

    base_box = gtk.HBox()
    base_box.pack_end(rhs_box, False, False)
    base_box.pack_end(make_vsep(3), False, False)
    base_box.pack_start(lhs_box)

    window.connect('key-release-event', handle_key_release_event)
    window.add_events(gtk.gdk.KEY_RELEASE_MASK)

    gobject.timeout_add(_STATUS_REFRESH_MS, refresh_status,
                        status_map, ui_state)

    for test in test_list:
        label_box = TestLabelBox(test)
        status_map.set_label_box(test, label_box)
        label_trough.pack_start(label_box, False, False)
        label_trough.pack_start(make_hsep(), False, False)

    window.add(base_box)
    window.show_all()

    ful.hide_cursor(window.window)

    test_widget_allocation = test_widget_box.get_allocation()
    test_widget_size = (test_widget_allocation.width,
                        test_widget_allocation.height)
    factory.log('test_widget_size = %s' % repr(test_widget_size))
    control_send(test_widget_size)

    console = Console(console_box.get_allocation())

    factory.log('factory_ui setup done, starting gtk.main()...')

    gtk.main()

    factory.log('factory_ui gtk.main() finished, exiting.')

if __name__ == '__main__':
    main()

# -*- coding: utf-8 -*-
#
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

AUTHOR = "Chrome OS Team"
NAME = "Factory"
TIME = "LONG"
TEST_CATEGORY = "Functional"
TEST_CLASS = "suite"
TEST_TYPE = "client"

DOC = """
This suite executed all of the factory tests, and incorporates an
X-windows GTK-based UI to highlight testing results and to allow
factory operators to switch between tests, and to re-run tests, all
on-demand via keyboard shortcuts.

The UI is implemented as a seperate process (see _FACTORY_UI_PATH),
which means that interprocess communication is needed between this
control, the UI, and the tests (which are forked children of this
control process).  """


import imp
import os

imp.load_source('common', job.autodir + '/bin/common.py')

from autotest_lib.client.bin import factory
from autotest_lib.client.bin import parallel


FACTORY_UI_PATH = job.autodir + '/bin/factory_ui'
STATUS_FILE_PATH = job.autodir + '/results/default/status'
TEST_LIST_PATH = job.autodir + '/site_tests/suite_Factory/test_list'


# Hack to grab the pid for forked tests.

from autotest_lib.client.bin.parallel import fork_waitfor as orig_fork_waitfor

def new_fork_waitfor(tmp, pid):
    factory.log_shared_data('active_test_data', (tmp, pid))
    orig_fork_waitfor(tmp, pid)

parallel.fork_waitfor = new_fork_waitfor


# These definitions are expose these classes directly into this
# namespace, so that the following exec'ed file can have cleaner
# syntax.  These are done in this fashion, as opposed to "from factory
# import <class>" to work-around Python namespace wackiness -- the
# from syntax does not work, creating new classes.
OperatorTest = factory.OperatorTest
InformationScreen = factory.InformationScreen
AutomatedSequence = factory.AutomatedSequence
AutomatedSubTest = factory.AutomatedSubTest
AutomatedRebootSubTest = factory.AutomatedRebootSubTest


# This exec defines TEST_LIST in global scope.
execfile(TEST_LIST_PATH)


# Hack to work around autotest's obsession with GRUB.
job.bootloader.set_default = lambda x: None
job.bootloader.boot_once = lambda x: None


def start_ui():
  ui_proc_args = [FACTORY_UI_PATH, TEST_LIST_PATH,
                  STATUS_FILE_PATH, str(os.getpid())]
  factory.log('starting ui %s' % repr(ui_proc_args))
  sp = subprocess.Popen(ui_proc_args, stdout=subprocess.PIPE)
  factory.log('waiting for ui to come up...')
  factory.log('got message from ui : %s' % repr(sp.stdout.readline().strip()))
  # TODO(hungte) define some protocol so that we know the UI failed to start.
  return sp

def stop_ui(ui_process):
    try:
        factory.log('stopping ui %d...' % ui_process.pid)
        ui_process.terminate()
        ui_process.kill()
        ui_process.wait()
        factory.log('ui process end with code: %d' % ui_process.returncode)
    except:
        factory.log('WARNING: failed to stop ui. ignored.')

def step_reboot_seq(next_subtest_info, total_iterations, i=0):
    if i < total_iterations:
        job.next_step_prepend([step_reboot_seq, next_subtest_info,
                               total_iterations, i + 1])
        factory.log('rebooting (iteration %d of %d)' % (i, total_iterations))
        job.reboot()
    else:
        step_init(next_subtest_info)

def find_next_test_to_run(status_map, test_db):
    test = status_map.next_untested()
    if test:
        return test
    # XXX When the status_map is corrupted, we may need to hack the list and
    # force some test to run. Currently we assume
    # factory.REVIEW_INFORMATION_TEST_UNIQUE_NAME is always runnable.
    review_test = test_db.get_test_by_unique_name(
            factory.REVIEW_INFORMATION_TEST_UNIQUE_NAME)
    if review_test:
        factory.log("HACK: Running %s" % str(review_test))
        return review_test
    return  None

def step_init(next_subtest_info=None):
    factory.log('TEST_LIST = %s' % repr(TEST_LIST))

    job.next_step([step_init])

    ui_process = start_ui()

    test_db = factory.TestDatabase(TEST_LIST)
    status_map = factory.StatusMap(TEST_LIST, STATUS_FILE_PATH)
    control_state = factory.ControlState(
        job, TEST_LIST, test_db, status_map, STATUS_FILE_PATH,
        parallel.fork_nuke_subprocess)

    def run_automated_sequence(test, count, start_index=0):
        for subtest in test.subtest_list[start_index:]:
            if isinstance(subtest, factory.AutomatedRebootSubTest):
                next_subtest_info = (test_db.get_tag_prefix(subtest), count)
                step_reboot_seq(next_subtest_info, subtest.iterations)
            else:
                shortcut_target = control_state.run_test(subtest, count)
            status_map.read_new_data()
            if shortcut_target:
                return shortcut_target
            if status_map.lookup_status(test) == factory.FAILED:
                return None

    if next_subtest_info:
        tag_prefix, count = next_subtest_info
        reboot_subtest = test_db.get_subtest_by_tag_prefix(tag_prefix)
        control_state.run_test(reboot_subtest, count)
        status_map.read_new_data()
        automated_seq = test_db.get_subtest_parent(reboot_subtest)
        rst_index = automated_seq.subtest_list.index(reboot_subtest)
        run_automated_sequence(automated_seq, count, start_index=rst_index + 1)

    test = find_next_test_to_run(status_map, test_db)
    while test is not None:
        unique_id_str = test_db.get_unique_id_str(test)
        count = status_map.lookup_count(test) + 1
        factory.log('control running test %s/%s' % (unique_id_str, count))
        if isinstance(test, factory.AutomatedSequence):
            shortcut_target = run_automated_sequence(test, count)
        else:
            shortcut_target = control_state.run_test(test, count)
            status_map.read_new_data()
        test = shortcut_target or find_next_test_to_run(status_map, test_db)

    # TODO(hungte) we may need to also stop UI when exception was raised.
    stop_ui(ui_process)

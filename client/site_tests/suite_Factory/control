# -*- coding: utf-8 -*-
#
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

AUTHOR = "Chrome OS Team"
NAME = "Factory"
TIME = "LONG"
TEST_CATEGORY = "Functional"
TEST_CLASS = "suite"
TEST_TYPE = "client"

DOC = """
This suite executed all of the factory tests, and incorporates an
X-windows GTK-based UI to highlight testing results and to allow
factory operators to switch between tests, and to re-run tests, all
on-demand via keyboard shortcuts.

The UI is implemented as a seperate process (see _FACTORY_UI_PATH),
which means that interprocess communication is needed between this
control, the UI, and the tests (which are forked children of this
control process).  """


import imp
imp.load_source('common', job.autodir + '/bin/common.py')
from autotest_lib.client.bin import factory
from autotest_lib.client.bin import utils


# These definitions are expose these classes directly into this
# namespace, so that the following exec'ed file can have cleaner
# syntax.  These are done in this fashion, as opposed to "from factory
# import <class>" to work-around Python namespace wackiness -- the
# from syntax does not work, creating new classes.
OperatorTest = factory.OperatorTest
InformationScreen = factory.InformationScreen
AutomatedSequence = factory.AutomatedSequence
AutomatedSubTest = factory.AutomatedSubTest
AutomatedRebootSubTest = factory.AutomatedRebootSubTest


# This exec defines TEST_LIST in global scope.
execfile(job.autodir + '/site_tests/suite_Factory/test_list')


# Hack to work around autotest's obsession with GRUB.
job.bootloader.set_default = lambda x: None
job.bootloader.boot_once = lambda x: None


def step_reboot_seq(tag_prefix, total_iterations, i=0):
    if i < total_iterations:
        job.next_step_prepend([step_reboot_seq, tag_prefix,
                               total_iterations, i + 1])
        factory.log('rebooting (iteration %d of %d)' % (i, total_iterations))
        job.reboot()
    else:
        step_init(intentional_reboot_subtest_tag_prefix=tag_prefix)


def step_init(intentional_reboot_subtest_tag_prefix=None):
    job.next_step([step_init])

    factory_ui_path = job.autodir + '/bin/factory_ui'
    status_file_path = job.autodir + '/results/default/status'

    status_map = factory.StatusMap(TEST_LIST, status_file_path)
    ui = factory.UiClient(TEST_LIST, factory_ui_path, status_file_path)
    control_state = factory.ControlState(job, TEST_LIST, ui, status_map,
                                         status_file_path)

    if intentional_reboot_subtest_tag_prefix:
        reboot_subtest = status_map.test_db.get_subtest_by_tag_prefix(
            intentional_reboot_subtest_tag_prefix)
        control_state.run_test(reboot_subtest)
        status_map.read_new_data()

    test = status_map.next_untested()
    while test is not None:
        if isinstance(test, factory.AutomatedSequence):
            for subtest in test.subtest_list:
                if isinstance(subtest, factory.AutomatedRebootSubTest):
                    tag_prefix = status_map.test_db.get_tag_prefix(subtest)
                    step_reboot_seq(tag_prefix, subtest.iterations)
                else:
                    control_state.run_test(subtest)
                if control_state.activated_kbd_shortcut_test:
                    break
        else:
            control_state.run_test(test)
        status_map.read_new_data()
        test = (control_state.activated_kbd_shortcut_test or
                status_map.next_untested())
